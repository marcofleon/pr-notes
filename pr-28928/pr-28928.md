# [28928](https://github.com/bitcoin/bitcoin/pull/28928/): add coverage for bech32m in `wallet_keypool_topup`

## Concepts to Understand
A keypool is a set of pre-generated (private and public) keys that a wallet maintains for immediate generation of new addresses without the need to generate new keys on the spot for every new transaction or address request. This makes it easier to avoid address reuse (privacy enhancement), as it's more efficient to get a new address from the keypool.

The "top up" here refers to when the keypool is replenished after the number of unused keys falls below a certain threshold. This is done automatically in the wallet to ensure that there's always a ready supply of new addresses that can be used for transactions.

## PR Improvements
This PR enhances the functional test `wallet_keypool_topup` by:
- adding bech32m addresses (introduced as part of the Taproot upgrade) to the test. It makes sure to do this only if descriptor wallets are being used. 
    ```bash
    output_types = ["legacy", "p2sh-segwit", "bech32"]
    if self.options.descriptors:
        output_types.append("bech32m")
    ```

- using multiple wallets on one node instead of multiple nodes. This simplifies the test setup quite a bit and still keeps the main functionality of testing keypool restoration. I'll check to see how much time is saved with this change.


## Brief Code Walkthrough

- For each address type, the test creates a new wallet, then generates 90 addresses to simulate usage of the initial keypool, and then an additional 20 addresses to trigger the wallet to extend the keypool.
    ```bash
    for _ in range(90):
        addr_oldpool = wallet.getnewaddress(address_type=output_type)
    for _ in range(20):
        addr_extpool = wallet.getnewaddress(address_type=output_type)
    ```

- The test sends funds to addresses from the initial and extended keypools, then mines a block to confirm these transactions.
    ```bash
    default_wallet.send(outputs=[{addr_oldpool:10}, {addr_extpool:5}])
    self.generate(node, 1)
    ```

- The wallet is unloaded and reloaded to simulate restoring from disk and checks that the balance is correct (15 BTC from the two transactions sent earlier).
    ```bash
    node.unloadwallet(wallet_name)
    node.loadwallet(wallet_name)

    assert_equal(wallet.getbalance(), 15)
    assert_equal(wallet.listtransactions()[0]['category'], "receive")
    ```

- The test checks, for each type, that the derivation path of the next address generated matches expectations, indicating that the wallet has correctly marked all used keys up to the highest key used.
    ```bash
    if output_type == 'legacy':
        assert_equal(wallet.getaddressinfo(wallet.getnewaddress(address_type=output_type))['hdkeypath'], "m/44h/1h/0h/0/110")
    elif output_type == 'p2sh-segwit':
        assert_equal(wallet.getaddressinfo(wallet.getnewaddress(address_type=output_type))['hdkeypath'], "m/49h/1h/0h/0/110")
    elif output_type == 'bech32':
        assert_equal(wallet.getaddressinfo(wallet.getnewaddress(address_type=output_type))['hdkeypath'], "m/84h/1h/0h/0/110")
    elif output_type == 'bech32m':
        assert_equal(wallet.getaddressinfo(wallet.getnewaddress(address_type=output_type))['hdkeypath'], "m/86h/1h/0h/0/110")
    ```